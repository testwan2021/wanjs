1.限流
场景：在秒杀团购下，再好的服务器也禁不住每秒百万的请求，为了避免过多请求造成服务器的压力，我需要在用户请求和DB之间增加一个mq.只有部分用户的请求
到数据库，其他的都在mq层平缓过度，让前台用户参与者得到抢购的友好提示。
怎么解决：限流算法，漏桶算法和令牌算法
漏洞算法->控制数据请求到网络的速率
令牌->控制数据请求到网络服务的数量
tomcat服务器自带连接池maxThreads，设置最大连接数
采用guava谷歌提供的RateLimiter就行api限流
nginx限流参数设置，单个IP限制每秒访问50次，一旦并发连接数超过我们的设置，将返回503错误给客户端

2.幂等性
场景：就是用户发一次请求和多次请求结果是一样的，比如在支付扣钱等场景中
解决方法：select 和delete都是天然的幂等性操作
可以利用唯一流水号实现，唯一索引表主键防止新增脏数据
token机制防止页面重复提交，把token放到redis
数据到达表前->向服务器申请token,放到redis,token有效时间，提交到后台校验，完成后，删除token,再返回新的token.(需要申请，一次有效)
悲观锁 select  for update
乐观锁 版本好version实现 或者 条件限制 库存数-购买数>0
api怎么保障幂等性：利用来源+来源序列号构成唯一索引，保障数据唯一

3.流量削峰
场景：在抢火车票和抢购时，瞬间的高并发，比如早晚高峰，流量削峰
解决：利用mq进行消息队列缓冲，在平滑过渡请求下发
流量漏斗削峰：分层过滤一下无效请求（redis缓存,cdn静态资源）

4.缓存击穿
key存在，在某一个点过期，有大量请求直接到了db.在redis.get(key)为空时，先设置一个key,再去查询db 并返回缓存，下一个请求就可以用缓存数据。
还可以设置永不过期，但是这种很消耗内存。

5.缓存穿透
缓存本身就没有，所有请求都是查数据库，利用不存在key 进行攻击。 （布隆过滤器 或者查询不到的数据也设置到缓存5分钟有效，防止别人攻击）

6.缓存雪崩
缓存集体失效在同一时刻，db压力大雪崩。解决：利用随机值设置过期时间，redis 哨兵模式，利用memcached缓存+降低，防止db挂，redis
持久化 快速恢复数据。



