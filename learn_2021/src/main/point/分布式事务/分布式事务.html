1.最终一致性如何保障100%高效可用
搭建一个中间消息确认中转服务A->
场景：把上游请求发送给A,A会插入一条记录，状态“待确认”，上游执行自己的本地库，成功-就确认刚才那条记录，失败-就删除
成功的话，就把消息推给下游mq,mq和可靠消息服务A本地操作开启一个事务，要么成功要么失败。再配合后台定时任务（springboot定时器）去扫各种转态，
根据状态来发出不同的处理。就是后台定时判断状态 做出对应的if  else 逻辑

2.TCC分布式原理
将一个任务拆成3步：try,confirm,cancel 两阶段补偿行方法
场景：
更改订单的状态为“已支付”
扣减商品库存
给会员增加积分
创建销售出库单通知仓库发货
解决方法：
老早的2pc-预提交 实际提交2步
tcc-预留资源（订单状态-更新中...、库存数、积分数、出库单） 确认资源
第一个阶段try 就是锁住资源，第二阶段确认资源（回滚或者提交）
核心：每个服务都要提供两个接口，一个用于第一阶段的资源预留行为，另一个用于确认/回滚。
通过transactional事务注解配合使用,主要在第一步预留的状态都为更新中，等待所有操作完成，才可以叫已完成，即confirm
比如商品数量，我们可以设置一个冻结数，第一步冻结数+1，返回用户看到的库存数=总数-冻结数
也可以结合些 springboot 定时Quartz  和 幂等性 逻辑

3.分布式事务解决方案
场景：在海量的数据环境中，为了提高查询效率和并发，会涉及分库分表或者分区，会把数据保存在不同的机器上，如何在不同机器节点保障事务。
下单场景下，库存和订单如果不在同一个节点上
解决：
方案一：2阶段提交2pc->增加一个协调者来参与决策是回滚还是提交，跟婚姻中介一样，需要他来中间协调。参与者发送事务给中介，中介根据
参与者都commit的反馈后，再来最终提交事务。缺点：在所有参与者如果一个发生网络问题就会造成事务不能提交，这种效率低，同步的，没有容错的机制。
方案二：tcc 补偿性事务
方案三：本地表（中间表）业务表和中间表在一个库，本身是满足事务的。缺点：消息表的逻辑会耦合到业务代码中，处理不好，会造成逻辑问题
方案四：mq消息队列->也是类似3个阶段，接受到消息->本地执行事务->结合接到的地址和本地状态来判断提交还是回滚，
缺点：这个很多主流mq不支持，部署复杂

4.分布式如何保障数据一致性？
目标：分布式事务（包含 强一致性zookeeper是cp,弱一致性 比如查询排名 ，最终一致性如 Mysql备份）
场景：
主库 从库和缓存直接的一致性场景
多个副本之间的一致性场景
分布式服务接口直接一致性场景
解决方案：
接口同步调用一致性处理：A->B交互，A发出B未收到，B收到没来及响应，可以采用服务调用重试方案和TCC方案（后端定时重试反查上游和下游状态+B的幂等性）
接口异步：A-B,由于B处理需要很长时间，需要异步回调通知A，（后台定时处理回调通知，尽可能通知到）
消息异步：（消息队列的异步通知ack,需要设置手动确认，也是定时+结合幂等性来处理+ack机制）
